<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://dimitri-voytan.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://dimitri-voytan.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-05-28T05:38:55+00:00</updated><id>https://dimitri-voytan.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Are Fourier Neural Operators Really Faster?</title><link href="https://dimitri-voytan.github.io/blog/2025/fno-seismic/" rel="alternate" type="text/html" title="Are Fourier Neural Operators Really Faster?"/><published>2025-05-26T00:00:00+00:00</published><updated>2025-05-26T00:00:00+00:00</updated><id>https://dimitri-voytan.github.io/blog/2025/fno-seismic</id><content type="html" xml:base="https://dimitri-voytan.github.io/blog/2025/fno-seismic/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>Fourier Neural Operators (FNOs) are often advertised as fast, mesh-invariant alternatives to traditional PDE solvers, with some studies claiming orders of magnitude speedups over classical methods, like finite-difference (FD). But do those claims hold up when we put FNOs head-to-head with optimized, GPU-accelerated FD codes? I’ve spent more time than I’m willing to admit trying to pin this down.</p> <p>In this post, I benchmark a state-of-the-art Tucker-tensorized FNO against hand-tuned FD solvers for four seismic wave physics formulations: isotropic acoustic, TTI-acoustic, isotropic elastic, and VTI-elastic. What I find is not altogether surprising: FNOs are usually slower—often <em>much</em> slower—unless you do some type of reduced-order modeling, like taking extremely large time steps or limiting the solution to just a surface.</p> <p>In this post I’m focusing primarily on seismic wave propogation problems, but the results <em>probably</em> extend to other linear PDEs of similar complexity. It would be straightforward to extend the code for that purpose.</p> <h2 id="background-solving-wave-equations">Background: Solving Wave Equations</h2> <p>Seismic wave simulations solve PDEs that model how waves travel through the Earth. One classic example is the 3D acoustic wave equation:</p> <p>$\frac{\partial^2 u}{\partial t^2} = c^2 \nabla^2 u$</p> <p>Finite difference methods discretize space and time into a grid, then update the wavefield with local stencils. They’re fast, parallelizable, and well-understood. But they get exponentially more expensive as you increase frequency, lower velocity, or demand high accuracy—you need finer grids and smaller time steps due to the Courant-Friedrichs-Lewy (CFL) condition and numerical dispersion.</p> <p>On the other hand, FNOs can be trained to learn a mapping from input fields (like velocity) to output fields (like pressure or displacement) using deep neural networks. This is the same “information” provided by the finite difference simulation. Crucially, FNOs work in the Fourier domain and apply learned convolutions via FFTs.</p> <h2 id="experiments">Experiments</h2> <p>I ran both FNOs and FD solvers on the same hardware (NVIDIA A100s) and carefully controlled for fair benchmarking:</p> <ul> <li>Same simulation domain size</li> <li>Same time duration (1/2 second)</li> <li>Same frequency content (30 Hz max)</li> <li>FD grid spacing = 10m (limited by points per wavelength)</li> <li>FNO spacing = 10m and 25m and 60Hz sample rate (Nyquist frequency in space and time)</li> <li>Varied model complexity: from simple acoustic to full anisotropic elasticity</li> <li>Ensure only the forward pass cost is recorded. No memory access latency.</li> </ul> <p>I didn’t train any models. Instead, I focused only on <em>inference time</em> — the cost of running the forward pass once the model is trained. The run time doesn’t depend on the specific weights, so you can save a lot of time by avoiding training.</p> <p>To ensure a fast finite difference solver, I used <a href="https://www.devitoproject.org/">Devito</a>. Devito generates optimized explicit finite difference codes from symbolically described PDE. It offers several performance benefits, including GPU acceleration, “out-of-the box”. I ran all simulations in 3 spatial dimensions, which is representative of the PDE simulations carried out today.</p> <h2 id="key-results">Key Results</h2> <h3 id="1-on-identical-grids-10m-spacing-fnos-are-always-slower">1. On identical grids (10m spacing), FNOs are <em>always</em> slower.</h3> <table> <thead> <tr> <th>Physics</th> <th>Small FNO (4 Layers, 12 Channels)</th> <th>Medium FNO (8 Layers, 24 Channels)</th> <th>Large FNO (12 Layers, 36 Channels)</th> </tr> </thead> <tbody> <tr> <td>Acoustic</td> <td>1.4x <em>slower</em></td> <td>27x <em>slower</em></td> <td>80x <em>slower</em></td> </tr> <tr> <td>VTI Elastic</td> <td>1.4x <em>slower</em></td> <td>3x <em>slower</em></td> <td>1.3x <em>slower</em></td> </tr> </tbody> </table> <p>The figure below gives a more comprehensive view of the performance characteristics. I fit a linear regression to the runtimes and report the slope ratio (speedup, assuming the y-intercept is 0). FNO is in blue and the other types of wave propagation, simulated with a finite difference solver, have their own color respectively.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/fno_seismic/fno_10_10_10-480.webp 480w,/assets/img/posts/fno_seismic/fno_10_10_10-800.webp 800w,/assets/img/posts/fno_seismic/fno_10_10_10-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/fno_seismic/fno_10_10_10.png" class="img-fluid rounded z-depth-1 zoomable=true " width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Runtime scaling when FNO and Finite difference are run on the same spatial grid (10 x 10 x 10m). I assume a temporal Nyquist frequency for FNO and the CFL limit for finite difference. The reported slope ratios indicate the speedup, relative to FNO. </div> <h3 id="2-if-we-allow-the-fno-to-use-a-coarser-25m-grid-it-can-catch-up">2. If we allow the FNO to use a coarser 25m grid, it can catch up.</h3> <table> <thead> <tr> <th>Physics</th> <th>Small FNO</th> <th>Medium FNO</th> <th>Large FNO</th> </tr> </thead> <tbody> <tr> <td>Acoustic</td> <td>1.25x <em>faster</em></td> <td>2.7x <em>slower</em></td> <td>6x <em>slower</em></td> </tr> <tr> <td>VTI Elastic</td> <td>9.65x <em>faster</em></td> <td>2.89x <em>faster</em></td> <td>1.30x <em>faster</em></td> </tr> </tbody> </table> <p>Only the smallest networks (4 layers, 12 channels) achieve consistent speedups. Bigger models, even on coarse grids, are still slower. In this regime, I believe that the risk of poor inference quality negates their benefits.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/fno_seismic/fno_25_25_25-480.webp 480w,/assets/img/posts/fno_seismic/fno_25_25_25-800.webp 800w,/assets/img/posts/fno_seismic/fno_25_25_25-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/fno_seismic/fno_25_25_25.png" class="img-fluid rounded z-depth-1 zoomable=true " width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Here, I've coarsened the FNO grid to 25 x 25 x 25 m and left the finite difference on the same grid. </div> <h3 id="3--predicting-only-the-surface-wavefield">3. Predicting <em>only the surface</em> wavefield.</h3> <p>If you restrict the FNO to predicting the full time history at a single depth (like the surface), it avoids recurrent inference and runs extremely fast. This was an approach proposed by <a href="https://www.sciencedirect.com/science/article/abs/pii/S0045782523008411">Lehman (2024).</a></p> <table> <thead> <tr> <th>Model</th> <th>Speedup over FD (VTI elastic)</th> </tr> </thead> <tbody> <tr> <td>FNO-Small</td> <td>4200x</td> </tr> <tr> <td>FNO-Medium</td> <td>1260x</td> </tr> <tr> <td>FNO-Large</td> <td>568x</td> </tr> </tbody> </table> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/fno_seismic/surface_wavefield-480.webp 480w,/assets/img/posts/fno_seismic/surface_wavefield-800.webp 800w,/assets/img/posts/fno_seismic/surface_wavefield-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/posts/fno_seismic/surface_wavefield.png" class="img-fluid rounded z-depth-1 zoomable=true " width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Here, I've predicting only the surface wavefield with FNO. </div> <h2 id="why-are-fnos-slower">Why Are FNOs Slower?</h2> <p>If you consider just a single timestep:</p> <ul> <li>FD scales as $O(p^d \beta^d N)$</li> <li>FNO scales as $O(L N \log N)$</li> </ul> <p>Where:</p> <ul> <li>$p$ = spatial derivative stencil width</li> <li>$\beta$ = oversampling factor (relative to Nyquist)</li> <li>$N$ = number of points in the domain</li> <li>$L$ = number of FNO layers</li> </ul> <p>In 3D, $p^d \beta^d$ grows fast, but not fast enough to offset the heavy lifting of FFTs unless the FNO network is <em>very</em> shallow.</p> <h2 id="when-are-fnos-useful">When Are FNOs Useful?</h2> <p>They <em>are</em> valuable in some cases:</p> <ul> <li><strong>Receiver-only predictions</strong> (e.g., marine acquisition)</li> <li><strong>Low-resolution surrogate models</strong> where full fidelity isn’t needed</li> </ul> <p>But for full-volume, high-res, time-domain simulations? They’re not competitive yet.</p> <p>Some caveats here. I optimized both finite difference and FNO codes reasonably well (compiling static graphs, turning off batch normalization, setting to inference mode, etc.), but optimization can he a never ending pit of work. I made a reasonably good effort to improve performance, but not exhaustive. Also, I didn’t consider half-precision runs e.g. <code class="language-plaintext highlighter-rouge">fp16</code> or <code class="language-plaintext highlighter-rouge">bf16</code>. It was not straightforward to get working in the FNO FFTs and support was only recently added to Devito. But the results shouldn’t change fundamentally if both could be run at half precision.</p> <h2 id="takeaways">Takeaways</h2> <ul> <li>FNOs are not faster than FD solvers for full-volume simulations</li> <li>Even on coarser grids, FNOs must be small to offer speedups</li> <li>Major gains come only when predicting surface fields (i.e., output dimensionality is reduced)</li> </ul> <p>If you’re designing an FNO for any linear PDE, benchmark it properly against a tuned FD code. And if you’re aiming for performance, remember that “learned” doesn’t always mean “faster.”</p> <image></image> <h2 id="read-more">Read More</h2> <ul> <li><a href="https://github.com">Code (Coming Soon!)</a></li> <li><a href="https://arxiv.org">Paper (Still in Review, Preprint Soon)</a></li> <li><a href="https://www.devitoproject.org/">Devito finite difference framework</a></li> <li><a href="https://arxiv.org/abs/2010.08895">Fourier Neural Operator original paper</a></li> <li><a href="https://arxiv.org/abs/2310.00120">Tucker-Tensorized FNO</a></li> </ul> <hr/>]]></content><author><name>Dimitri Voytan</name></author><category term="NeuralOperators"/><category term="Ai4Science"/><summary type="html"><![CDATA[I challenge the performance benefits of Fourier Neural Operators, particularly for linear wave propagation problems]]></summary></entry></feed>